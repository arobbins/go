{
  "name": "flightplan",
  "description": "Library for streamlining application deployment or systems administration tasks",
  "version": "0.5.5",
  "author": {
    "name": "Patrick Stadler",
    "email": "patrick.stadler@gmail.com"
  },
  "keywords": [
    "deploy",
    "deployment",
    "commands",
    "devops",
    "exec",
    "shell",
    "ssh",
    "tasks",
    "parallel",
    "sequential",
    "remote",
    "local",
    "fabric"
  ],
  "readmeFilename": "README.md",
  "homepage": "https://github.com/pstadler/flightplan",
  "repository": {
    "type": "git",
    "url": "https://github.com/pstadler/flightplan"
  },
  "bugs": {
    "url": "https://github.com/pstadler/flightplan/issues"
  },
  "bin": {
    "fly": "./bin/fly.js"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "byline": "^4.1.1",
    "chalk": "^0.5.1",
    "fibers": "^1.0.2",
    "liftoff": "^0.13.6",
    "nopt": "^3.0.1",
    "pretty-hrtime": "^0.2.2",
    "prompt": "^0.2.14",
    "semver": "^4.1.0",
    "ssh2": "^0.3.6",
    "temp-write": "^1.1.0",
    "util-extend": "^1.0.1",
    "v8flags": "^1.0.1"
  },
  "license": "MIT",
  "devDependencies": {
    "gulp": "^3.8.10",
    "gulp-jshint": "^1.9.0",
    "jshint-stylish": "^1.0.0",
    "markdox": "^0.1.7"
  },
  "readme": "# Flightplan ✈ [![NPM version][npm-version-image]][npm-url] [![NPM downloads][npm-downloads-image]][npm-url] [![MIT License][license-image]][license-url]\n\nRun sequences of commands against local and remote hosts.\n\nFlightplan is a [node.js](http://nodejs.org) library for streamlining application deployment or systems administration tasks, similar to Python's [Fabric](http://fabfile.org).\n\n**Flightplan 0.5.0 has been rewritten from scratch and is not compatible with 0.4.x releases. Read more about what's changed in the [release notes](https://github.com/pstadler/flightplan/releases/tag/0.5.0).**\n\n## Installation & Usage\n\n```bash\n# install the cli tool\n$ npm install -g flightplan\n\n# use it in your project\n$ npm install flightplan --save-dev\n\n# run a flightplan (`fly --help` for more information)\n$ fly [task:]<target> [--flightplan flightplan.(js|coffee)]\n```\n\nBy default, the `fly` command will try to load `flightplan.js` or `flightplan.coffee`.\n\n## Sample flightplan.js\n\n```javascript\n// flightplan.js\nvar plan = require('flightplan');\n\n// configuration\nplan.target('staging', {\n  host: 'staging.example.com',\n  username: 'pstadler',\n  agent: process.env.SSH_AUTH_SOCK\n});\n\nplan.target('production', [\n  {\n    host: 'www1.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  },\n  {\n    host: 'www2.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  }\n]);\n\nvar tmpDir = 'example-com-' + new Date().getTime();\n\n// run commands on localhost\nplan.local(function(local) {\n  local.log('Run build');\n  local.exec('gulp build');\n\n  local.log('Copy files to remote hosts');\n  var filesToCopy = local.exec('git ls-files', {silent: true});\n  // rsync files to all the target's remote hosts\n  local.transfer(filesToCopy, '/tmp/' + tmpDir);\n});\n\n// run commands on the target's remote hosts\nplan.remote(function(remote) {\n  remote.log('Move folder to web root');\n  remote.sudo('cp -R /tmp/' + tmpDir + ' ~', {user: 'www'});\n  remote.rm('-rf /tmp/' + tmpDir);\n\n  remote.log('Install dependencies');\n  remote.sudo('npm --production --prefix ~/' + tmpDir\n                            + ' install ~/' + tmpDir, {user: 'www'});\n\n  remote.log('Reload application');\n  remote.sudo('ln -snf ~/' + tmpDir + ' ~/example-com', {user: 'www'});\n  remote.sudo('pm2 reload example-com', {user: 'www'});\n});\n\n// run more commands on localhost afterwards\nplan.local(function(local) { /* ... */ });\n// ...or on remote hosts\nplan.remote(function(remote) { /* ... */ });\n```\n\n# Documentation\n\n<!-- DOCS -->\n[Flightplan](#user-content-Flightplan)\n* [target(name, hosts[, options])](#user-content-flightplan.target(name%2C%20hosts%5B%2C%20options%5D))\n* [local([tasks, ]fn)](#user-content-flightplan.local(%5Btasks%2C%20%5Dfn))\n* [remote([tasks, ]fn)](#user-content-flightplan.remote(%5Btasks%2C%20%5Dfn))\n* [abort([message])](#user-content-flightplan.abort(%5Bmessage%5D))\n\n[Transport](#user-content-Transport)\n* [exec(command[, options])](#user-content-transport.exec(command%5B%2C%20options%5D))\n* [sudo(command[, options])](#user-content-transport.sudo(command%5B%2C%20options%5D))\n* [transfer(files, remoteDir[, options])](#user-content-transport.transfer(files%2C%20remoteDir%5B%2C%20options%5D))\n* [prompt(message[, options])](#user-content-transport.prompt(message%5B%2C%20options%5D))\n* [waitFor(fn(done))](#user-content-transport.waitFor(fn(done)))\n* [with(command|options[, options], fn)](#user-content-transport.with(command%7Coptions%5B%2C%20options%5D%2C%20fn))\n* [silent()](#user-content-transport.silent())\n* [verbose()](#user-content-transport.verbose())\n* [failsafe()](#user-content-transport.failsafe())\n* [unsafe()](#user-content-transport.unsafe())\n* [log(message)](#user-content-transport.log(message))\n* [debug(message)](#user-content-transport.debug(message))\n\n<!-- Start lib/index.js -->\n\n## <a name=\"Flightplan\"></a>Flightplan\n\nA flightplan is a set of subsequent flights to be executed on one or more\nhosts. Configuration is handled with the `target()` method.\n\n```javascript\nvar plan = require('flightplan');\n```\n\n### Flights\nA flight is a set of commands to be executed on one or more hosts. There are\ntwo types of flights:\n\n#### Local flights\n\nCommands in local flights are executed on the **localhost**.\n\n```javascript\nplan.local(function(transport) {\n  transport.hostname(); // prints the hostname of localhost\n});\n```\n\n#### Remote flights\n\nCommands in remote flights are executed in **parallel** against\nremote hosts defined during the briefing.\n\n```javascript\nplan.remote(function(transport) {\n  transport.hostname(); // prints the hostname(s) of the remote host(s)\n});\n```\n\nYou can define multiple flights of each type. They will be executed in the\norder of their definition. If a previous flight failed, all subsequent\nflights won't get executed. For more information about what it means for\na flight to fail, see the section about `Transport`.\n\n```javascript\n// executed first\nplan.local(function(transport) {});\n\n// executed if first flight succeeded\nplan.remote(function(transport) {});\n\n// executed if second flight succeeded\nplan.local(function(transport) {});\n\n// ...\n```\n\n### Tasks\nFlightplan supports optional tasks to run a subset of flights.\n\n```javascript\n// fly deploy:<target>\nplan.local('deploy', function(transport) {});\n\n// fly build:<target>\nplan.local('build', function(transport) {});\n\n// fly deploy:<target> or...\n// fly build:<target>\nplan.local(['deploy', 'build'], function(transport) {});\nplan.remote(['deploy', 'build'], function(transport) {});\n```\n\nIf no task is specified it's implicitly set to \"default\". Therefore,\n`fly <target>` is the same as `fly default:<target>`.\n\n```javascript\n// fly <target>\nplan.local(function(transport) {});\n// is the same as...\nplan.local('default', function(transport) {});\n// \"default\" + other tasks:\nplan.remote(['default', 'deploy', 'build'], function(transport) {});\n```\n\n### <a name=\"flightplan.target(name%2C%20hosts%5B%2C%20options%5D)\"></a>flightplan.target(name, hosts[, options]) → this \n\nConfigure the flightplan's targets with `target()`. Without a\nproper setup you can't do remote flights which require at\nleast one remote host. Each target consists of one ore more hosts.\n\nValues in the hosts section are passed directly to the `connect()`\nmethod of [mscdex/ssh2](https://github.com/mscdex/ssh2#connection-methods)\nwith one exception: `privateKey` needs to be passed as a string\ncontaining the path to the keyfile instead of the key itself.\n\n```javascript\n// run with `fly staging`\nplan.target('staging', {\n  // see: https://github.com/mscdex/ssh2#connection-methods\n  host: 'staging.example.com',\n  username: 'pstadler',\n  agent: process.env.SSH_AUTH_SOCK\n});\n\n// run with `fly production`\nplan.target('production', [\n  {\n    host: 'www1.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  },\n  {\n    host: 'www2.example.com',\n    username: 'pstadler',\n    agent: process.env.SSH_AUTH_SOCK\n  }\n]);\n```\n\nYou can override the `username` value of hosts by calling `fly` with\nthe `-u|--username` option:\n\n```bash\nfly production --username=admin\n```\n\n#### Defining and using properties depending on the target\n\n`target()` takes an optional third argument to define properties used by\nthis target. Values defined in this way can be accessed during runtime.\n\n```javascript\nplan.target('staging', {...}, {\n  webRoot: '/usr/local/www',\n  sudoUser: 'www'\n});\n\nplan.target('production', {...}, {\n  webRoot: '/home/node',\n  sudoUser: 'node'\n});\n\nplan.remote(function(remote) {\n  var webRoot = plan.runtime.options.webRoot;   // fly staging -> '/usr/local/www'\n  var sudoUser = plan.runtime.options.sudoUser; // fly staging -> 'www'\n  remote.sudo('ls -al ' + webRoot, {user: sudoUser});\n});\n```\n\nProperties can be set and overwritten by passing them as named options to the\n `fly` command.\n\n```bash\n$ fly staging --sudoUser=foo\n# plan.runtime.options.sudoUser -> 'foo'\n```\n\n### <a name=\"flightplan.local(%5Btasks%2C%20%5Dfn)\"></a>flightplan.local([tasks, ]fn) → this \n\nCalling this method registers a local flight. Local flights are\nexecuted on your localhost. When `fn` gets called a `Transport` object\nis passed with the first argument.\n\n```javascript\nplan.local(function(local) {\n  local.echo('hello from your localhost.');\n});\n```\n\nAn optional first parameter of type Array or String can be passed for\ndefining the flight's task(s).\n\n### <a name=\"flightplan.remote(%5Btasks%2C%20%5Dfn)\"></a>flightplan.remote([tasks, ]fn) → this \n\nRegister a remote flight. Remote flights are executed on the current\ntarget's remote hosts defined with `briefing()`. When `fn` gets called\na `Transport` object is passed with the first argument.\n\n```javascript\nplan.remote(function(remote) {\n  remote.echo('hello from the remote host.');\n});\n```\n\nAn optional first parameter of type Array or String can be passed for\ndefining the flight's task(s).\n\n### <a name=\"flightplan.abort(%5Bmessage%5D)\"></a>flightplan.abort([message])\n\nManually abort the current flightplan and prevent any further commands and\nflights from being executed. An optional message can be passed which\nis displayed after the flight has been aborted.\n\n```javascript\nplan.abort('Severe turbulences over the atlantic ocean!');\n```\n\n<!-- End lib/index.js -->\n\n<!-- Start lib/transport/index.js -->\n\n## <a name=\"Transport\"></a>Transport\n\nA transport is the interface you use during flights. Basically they\noffer you a set of methods to execute a chain of commands. Depending on the\ntype of flight, this is either a `Shell` object for local\nflights, or an `SSH` for remote flights. Both transports\nexpose the same set of methods as described in this section.\n\n```javascript\nplan.local(function(local) {\n  local.echo('Shell.echo() called');\n});\n\nplan.remote(function(remote) {\n  remote.echo('SSH.echo() called');\n});\n```\n\nWe call the Transport object `transport` in the following section to avoid\nconfusion. However, do yourself a favor and use `local` for local, and\n`remote` for remote flights.\n\n#### Accessing runtime information\n\nFlightplan provides information during flights with the `runtime` properties:\n\n```javascript\nplan.remote(function(transport) { // applies to local flights as well\n  // Flightplan specific information\n  console.log(plan.runtime.task);    // 'default'\n  console.log(plan.runtime.target);  // 'production'\n  console.log(plan.runtime.hosts);   // [{ host: 'www1.example.com', port: 22 }, ...]\n  console.log(plan.runtime.options); // { debug: true, ... }\n\n  // Flight specific information\n  console.log(transport.runtime); // { host: 'www1.example.com', port: 22 }\n});\n```\n\n### <a name=\"transport.exec(command%5B%2C%20options%5D)\"></a>transport.exec(command[, options]) → code: int, stdout: String, stderr: String\n\nTo execute a command you have the choice between using `exec()` or one\nof the handy wrappers for often used commands:\n`transport.exec('ls -al')` is the same as `transport.ls('-al')`. If a\ncommand returns a non-zero exit code, the flightplan will be aborted and\nall subsequent commands and flights won't get executed.\n\n#### Options\nOptions can be passed as a second argument. If `failsafe: true` is\npassed, the command is allowed to fail (i.e. exiting with a non-zero\nexit code), whereas `silent: true` will simply suppress its output.\n\n```javascript\n// output of `ls -al` is suppressed\ntransport.ls('-al', {silent: true});\n\n// flightplan continues even if command fails with exit code `1`\ntransport.ls('-al foo', {failsafe: true}); // ls: foo: No such file or directory\n\n// both options together\ntransport.ls('-al foo', {silent: true, failsafe: true});\n```\n\nTo apply these options to multiple commands check out the docs of\n`transport.silent()` and `transport.failsafe()`.\n\n#### Return value\nEach command returns an object containing `code`, `stdout` and`stderr`:\n\n```javascript\nvar result = transport.echo('Hello world');\nconsole.log(result); // { code: 0, stdout: 'Hello world\\n', stderr: null }\n```\n\n#### Advanced options\nFlightplan uses `child_process#exec()` for executing local commands and\n`mscdex/ssh2#exec()` for remote commands. Options passed with `exec` will\nbe forwarded to either of these functions.\n\n```javascript\n// increase maxBuffer for child_process#exec()\nlocal.ls('-al', {exec: {maxBuffer: 2000*1024}});\n\n// enable pty for mscdex/ssh2#exec()\nremote.ls('-al', {exec: {pty: true}});\n```\n\n### <a name=\"transport.sudo(command%5B%2C%20options%5D)\"></a>transport.sudo(command[, options]) → code: int, stdout: String, stderr: String\n\nExecute a command as another user with `sudo()`. It has the same\nsignature as `exec()`. Per default, the user under which the command\nwill be executed is \"root\". This can be changed by passing\n`user: \"name\"` with the second argument:\n\n```javascript\n// will run: sudo -u root -i bash -c 'Hello world'\ntransport.sudo('echo Hello world');\n\n// will run sudo -u www -i bash -c 'Hello world'\ntransport.sudo('echo Hello world', {user: 'www'});\n\n// further options passed (see `exec()`)\ntransport.sudo('echo Hello world', {user: 'www', silent: true, failsafe: true});\n```\n\nFlightplan's `sudo()` requires a certain setup on your host. In order to\nmake things work on a typical Ubuntu installation, follow these rules:\n\n```bash\n# Scenario:\n# 'pstadler' is the user for connecting to the host and 'www' is the user\n# under which you want to execute commands with sudo.\n\n# 1. 'pstadler' has to be in the sudo group:\n$ groups pstadler\npstadler : pstadler sudo\n\n# 2. 'pstadler' needs to be able to run sudo -u 'www' without a password.\n# In order to do this, add the following line to /etc/sudoers:\npstadler ALL=(www) NOPASSWD: ALL\n\n# 3. user 'www' needs to have a login shell (e.g. bash, sh, zsh, ...)\n$ cat /etc/passwd | grep www\nwww:x:1002:1002::/home/www:/bin/bash   # GOOD\nwww:x:1002:1002::/home/www:/bin/false  # BAD\n```\n\n### <a name=\"transport.transfer(files%2C%20remoteDir%5B%2C%20options%5D)\"></a>transport.transfer(files, remoteDir[, options]) → [results] \n\nCopy a list of files to the current target's remote host(s) using\n`rsync` with the SSH protocol. File transfers are executed in parallel.\n After finishing all transfers, an array containing results from\n`transport.exec()` is returned. This method is only available on local\nflights.\n\n```javascript\nvar files = ['path/to/file1', 'path/to/file2'];\nlocal.transfer(files, '/tmp/foo');\n```\n\n#### Files argument\nTo make things more comfortable, the `files` argument doesn't have to be\npassed as an array. Results from previous commands and zero-terminated\nstrings are handled as well:\n\n```javascript\n// use result from a previous command\nvar files = local.git('ls-files', {silent: true}); // get list of files under version control\nlocal.transfer(files, '/tmp/foo');\n\n// use zero-terminated result from a previous command\nvar files = local.exec('(git ls-files -z;find node_modules -type f -print0)', {silent: true});\nlocal.transfer(files, '/tmp/foo');\n\n// use results from multiple commands\nvar result1 = local.git('ls-files', {silent: true}).stdout.split('\\n');\nvar result2 = local.find('node_modules -type f', {silent: true}).stdout.split('\\n');\nvar files = result1.concat(result2);\nfiles.push('path/to/another/file');\nlocal.transfer(files, '/tmp/foo');\n```\n\n`transfer()` will use the current host's username defined with\n`briefing()` unless `fly` is called with the `-u|--username` option.\nIn this case the latter will be used. If debugging is enabled\n(either with `briefing()` or with `fly --debug`), `rsync` is executed\nin verbose mode (`-vv`).\n\n### <a name=\"transport.prompt(message%5B%2C%20options%5D)\"></a>transport.prompt(message[, options]) → input \n\nPrompt for user input.\n\n```javascript\nvar input = transport.prompt('Are you sure you want to continue? [yes]');\nif(input.indexOf('yes') === -1) {\n  plan.abort('User canceled flight');\n}\n\n// prompt for password (with UNIX-style hidden input)\nvar password = transport.prompt('Enter your password:', { hidden: true });\n\n// prompt when deploying to a specific target\nif(plan.runtime.target === 'production') {\n  var input = transport.prompt('Ready for deploying to production? [yes]');\n  if(input.indexOf('yes') === -1) {\n    plan.abort('User canceled flight');\n  }\n}\n```\n\n### <a name=\"transport.waitFor(fn(done))\"></a>transport.waitFor(fn(done)) → mixed \n\nExecute a function and return after the callback `done` is called.\nThis is used for running asynchronous functions in a synchronous way.\n\nThe callback takes an optional argument which is then returned by\n`waitFor()`.\n\n```javascript\nvar result = transport.waitFor(function(done) {\n  require('node-notifier').notify({\n      message: 'Hello World'\n    }, function(err, response) {\n      done(err || 'sent!');\n    });\n});\nconsole.log(result); // 'sent!'\n```\n\n### <a name=\"transport.with(command%7Coptions%5B%2C%20options%5D%2C%20fn)\"></a>transport.with(command|options[, options], fn)\n\nExecute commands with a certain context.\n\n```javascript\ntransport.with('cd /tmp', function() {\n  transport.ls('-al'); // 'cd /tmp && ls -al'\n});\n\ntransport.with({silent: true, failsafe: true}, function() {\n  transport.ls('-al'); // output suppressed, fail safely\n});\n\ntransport.with('cd /tmp', {silent: true}, function() {\n  transport.ls('-al'); // 'cd /tmp && ls -al', output suppressed\n});\n```\n\n### <a name=\"transport.silent()\"></a>transport.silent()\n\nWhen calling `silent()` all subsequent commands are executed without\nprinting their output to stdout until `verbose()` is called.\n\n```javascript\ntransport.ls(); // output will be printed to stdout\ntransport.silent();\ntransport.ls(); // output won't be printed to stdout\n```\n\n### <a name=\"transport.verbose()\"></a>transport.verbose()\n\nCalling `verbose()` reverts the behavior introduced with `silent()`.\nOutput of commands will be printed to stdout.\n\n```javascript\ntransport.silent();\ntransport.ls(); // output won't be printed to stdout\ntransport.verbose();\ntransport.ls(); // output will be printed to stdout\n```\n\n### <a name=\"transport.failsafe()\"></a>transport.failsafe()\n\nWhen calling `failsafe()`, all subsequent commands are allowed to fail\nuntil `unsafe()` is called. In other words, the flight will continue\neven if the return code of the command is not `0`. This is helpful if\neither you expect a command to fail or their nature is to return a\nnon-zero exit code.\n\n```javascript\ntransport.failsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\ntransport.log('Previous command failed, but flight was not aborted');\n```\n\n### <a name=\"transport.unsafe()\"></a>transport.unsafe()\n\nCalling `unsafe()` reverts the behavior introduced with `failsafe()`.\nThe flight will be aborted if a subsequent command fails (i.e. returns\na non-zero exit code). This is the default behavior.\n\n```javascript\ntransport.failsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\ntransport.log('Previous command failed, but flight was not aborted');\ntransport.unsafe();\ntransport.ls('foo'); // ls: foo: No such file or directory\n// flight aborted\n```\n\n### <a name=\"transport.log(message)\"></a>transport.log(message)\n\nPrint a message to stdout. Flightplan takes care that the message\nis formatted correctly within the current context.\n\n```javascript\ntransport.log('Copying files to remote hosts');\n```\n\n### <a name=\"transport.debug(message)\"></a>transport.debug(message)\n\nPrint a debug message to stdout if debug mode is enabled. Flightplan\ntakes care that the message is formatted correctly within the current\ncontext.\n\n```javascript\ntransport.debug('Copying files to remote hosts');\n```\n\n<!-- End lib/transport/index.js -->\n\n<!-- ENDDOCS -->\n\n[npm-url]: https://npmjs.org/package/flightplan\n[npm-version-image]: http://img.shields.io/npm/v/flightplan.svg?style=flat-square\n[npm-downloads-image]: http://img.shields.io/npm/dm/flightplan.svg?style=flat-square\n\n[license-url]: LICENSE\n[license-image]: http://img.shields.io/badge/license-MIT-blue.svg?style=flat-square\n",
  "_id": "flightplan@0.5.5",
  "_from": "flightplan@"
}
